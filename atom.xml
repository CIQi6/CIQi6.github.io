<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Memetor&#39;s Blog</title>
  
  
  <link href="https://lightc.top/atom.xml" rel="self"/>
  
  <link href="https://lightc.top/"/>
  <updated>2024-03-13T10:12:13.036Z</updated>
  <id>https://lightc.top/</id>
  
  <author>
    <name>Memetor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mit6-S081-Notes-ch2</title>
    <link href="https://lightc.top/2024/03/13/mit6-S081-Notes-ch2/"/>
    <id>https://lightc.top/2024/03/13/mit6-S081-Notes-ch2/</id>
    <published>2024-03-13T07:55:17.000Z</published>
    <updated>2024-03-13T10:12:13.036Z</updated>
    
    
    
    
    
    <category term="OS" scheme="https://lightc.top/tags/OS/"/>
    
    <category term="Mit6.s081" scheme="https://lightc.top/tags/Mit6-s081/"/>
    
  </entry>
  
  <entry>
    <title>反向调试和rr</title>
    <link href="https://lightc.top/2024/03/12/%E5%8F%8D%E5%90%91%E8%B0%83%E8%AF%95%E5%92%8Crr/"/>
    <id>https://lightc.top/2024/03/12/%E5%8F%8D%E5%90%91%E8%B0%83%E8%AF%95%E5%92%8Crr/</id>
    <published>2024-03-12T09:58:14.000Z</published>
    <updated>2024-03-12T10:38:17.503Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反向调试&quot;&gt;&lt;a href=&quot;#反向调试&quot; class=&quot;headerlink&quot; title=&quot;反向调试&quot;&gt;&lt;/a&gt;反向调试&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h</summary>
      
    
    
    
    
    <category term="reverse debugging" scheme="https://lightc.top/tags/reverse-debugging/"/>
    
    <category term="rr" scheme="https://lightc.top/tags/rr/"/>
    
  </entry>
  
  <entry>
    <title>mit6.S081-Notes-ch1</title>
    <link href="https://lightc.top/2024/03/07/mit6-S081-Notes-ch1/"/>
    <id>https://lightc.top/2024/03/07/mit6-S081-Notes-ch1/</id>
    <published>2024-03-07T05:27:37.000Z</published>
    <updated>2024-03-13T07:54:32.752Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;p&gt;操作系统是一个软件，它管理计算机资源， 为其他软件提供方便的服务。&lt;/p&gt;
&lt;p&gt;操作系统负责计算机硬件资源的分配，让 Mi</summary>
      
    
    
    
    
    <category term="os" scheme="https://lightc.top/tags/os/"/>
    
    <category term="unix" scheme="https://lightc.top/tags/unix/"/>
    
    <category term="mit6.s081" scheme="https://lightc.top/tags/mit6-s081/"/>
    
  </entry>
  
  <entry>
    <title>Statistical learning basic</title>
    <link href="https://lightc.top/2024/02/14/Statistical-learning-basic/"/>
    <id>https://lightc.top/2024/02/14/Statistical-learning-basic/</id>
    <published>2024-02-14T00:19:28.000Z</published>
    <updated>2024-02-14T00:20:13.935Z</updated>
    
    
    
    
    
    <category term="Statistical learning" scheme="https://lightc.top/tags/Statistical-learning/"/>
    
  </entry>
  
  <entry>
    <title>trie</title>
    <link href="https://lightc.top/2024/01/15/trie/"/>
    <id>https://lightc.top/2024/01/15/trie/</id>
    <published>2024-01-15T11:48:22.000Z</published>
    <updated>2024-01-15T13:46:29.491Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于搜索问题——从一堆数据中检索(retireve)我们感兴趣的数据，我们前面已经了解到了许多抽象数据结构以及其对应的具体实现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;数据结构&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;存储操作&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;主要检索操作&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;检索方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;List&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;add(key), insert(key, index)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;get(index)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;index&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Map&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;put(key, value)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;get(key)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;key identity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Set&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;add(key)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;containsKey(key)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;key identity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Priority Queue&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;add(key)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;getSmallest()&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;key order&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Disjoint Sets&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;connect(int_a, int_b)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;isConnected(int_a, int_b)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;two integer values&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="trie" scheme="https://lightc.top/tags/trie/"/>
    
    <category term="algorithmn" scheme="https://lightc.top/tags/algorithmn/"/>
    
  </entry>
  
  <entry>
    <title>Relflection-java</title>
    <link href="https://lightc.top/2024/01/05/Relflection-java/"/>
    <id>https://lightc.top/2024/01/05/Relflection-java/</id>
    <published>2024-01-05T05:18:51.000Z</published>
    <updated>2024-01-12T16:05:37.892Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是反射&quot;&gt;&lt;a href=&quot;#什么是反射&quot; class=&quot;headerlink&quot; title=&quot;什么是反射&quot;&gt;&lt;/a&gt;什么是反射&lt;/h2&gt;&lt;p&gt;反射就是程序在&lt;code&gt;运行时&lt;/code&gt;能够“观察”和修改自己的行为。&lt;/p&gt;
&lt;p&gt;JAVA反射机制是在运行</summary>
      
    
    
    
    
    <category term="java" scheme="https://lightc.top/tags/java/"/>
    
    <category term="Reflection" scheme="https://lightc.top/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>Shortest_Path</title>
    <link href="https://lightc.top/2023/12/31/Shortest-Path/"/>
    <id>https://lightc.top/2023/12/31/Shortest-Path/</id>
    <published>2023-12-31T05:50:30.000Z</published>
    <updated>2023-12-31T05:50:30.528Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Testing</title>
    <link href="https://lightc.top/2023/12/31/Equality_Testing/"/>
    <id>https://lightc.top/2023/12/31/Equality_Testing/</id>
    <published>2023-12-31T05:05:09.000Z</published>
    <updated>2023-12-31T05:37:36.436Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Equality-Testing&quot;&gt;&lt;a href=&quot;#Equality-Testing&quot; class=&quot;headerlink&quot; title=&quot;Equality Testing&quot;&gt;&lt;/a&gt;Equality Testing&lt;/h2&gt;&lt;p&gt;java 规定 equals 方法应该要满足以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自反性：对于非 NULL 引用 x， &lt;code&gt;x.equals(x)&lt;/code&gt;应该返回 true&lt;/li&gt;
&lt;li&gt;对称性：对于任何 x 和 y，&lt;code&gt;x.eqauls(y)&lt;/code&gt; 和 &lt;code&gt;y.equals(x)&lt;/code&gt; 返回的结果应该相同&lt;/li&gt;
&lt;li&gt;传递性：对于任何 x 、y 和 z，&lt;code&gt;x.equals(y)&lt;/code&gt; 、&lt;code&gt;y.equals(z)&lt;/code&gt; 则 &lt;code&gt;x.equals(z)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一致性：只要 x 和 y 不变，则无论调用多少次，什么时候调用 x.equals(y) ，返回的值应该不变&lt;/li&gt;
&lt;li&gt;对于 x.equals(null) 应该返回 false&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://lightc.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>PIMPL</title>
    <link href="https://lightc.top/2023/12/19/PIMPL/"/>
    <id>https://lightc.top/2023/12/19/PIMPL/</id>
    <published>2023-12-19T09:00:08.000Z</published>
    <updated>2023-12-30T13:00:17.283Z</updated>
    
    
    <summary type="html">&lt;p&gt;Pimpl (Pointer to implementation) 是一种减少代码依赖和编译时间的 cpp 代码技巧。&lt;/p&gt;
&lt;p&gt;Pimpl 的思想是将可见类的实现放在一个单独的实现类中，在可见类中使用一个私有指针来访问实现类。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://lightc.top/tags/cpp/"/>
    
    <category term="cppIdioms" scheme="https://lightc.top/tags/cppIdioms/"/>
    
  </entry>
  
  <entry>
    <title>graph</title>
    <link href="https://lightc.top/2023/12/17/graph/"/>
    <id>https://lightc.top/2023/12/17/graph/</id>
    <published>2023-12-17T07:11:17.000Z</published>
    <updated>2024-03-30T02:19:15.547Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;图的概念&quot;&gt;&lt;a href=&quot;#图的概念&quot; class=&quot;headerlink&quot; title=&quot;图的概念&quot;&gt;&lt;/a&gt;图的概念&lt;/h2&gt;&lt;p&gt;图由结点和边组成。&lt;/p&gt;
&lt;p&gt;树也是图。&lt;/p&gt;
&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h2&gt;&lt;p&gt;有向图和无向图：如果边只能从一段到另一端，则叫有向边，对应的图为有向图(Directed graph)，反之为无向图(Undirected graph)。&lt;/p&gt;
&lt;p&gt;路径和循环：从一个结点A到另一个结点B的边序列叫做从 A 到 B 的路径(Path)。从出发点和终点相同的路径叫做循环(Cycle)。&lt;/p&gt;
&lt;p&gt;没有重复结点的路径叫做简单路径；除了起点和终点，没有重复结点的循环叫做简单循环。&lt;/p&gt;
&lt;p&gt;连接：如果结点 A 和 结点 B 存在路径，则说 A 和 B 连接。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="https://lightc.top/tags/Algorithm/"/>
    
    <category term="Graph" scheme="https://lightc.top/tags/Graph/"/>
    
    <category term="Graph Traversals" scheme="https://lightc.top/tags/Graph-Traversals/"/>
    
  </entry>
  
  <entry>
    <title>tree</title>
    <link href="https://lightc.top/2023/12/17/tree/"/>
    <id>https://lightc.top/2023/12/17/tree/</id>
    <published>2023-12-17T07:11:11.000Z</published>
    <updated>2023-12-17T10:37:21.012Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是树？&quot;&gt;&lt;a href=&quot;#什么是树？&quot; class=&quot;headerlink&quot; title=&quot;什么是树？&quot;&gt;&lt;/a&gt;什么是树？&lt;/h2&gt;&lt;p&gt;树的组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一组节点 (nodes)&lt;/li&gt;
&lt;li&gt;一组连接着节点的边 (edges)&lt;ul&gt;
&lt;li&gt;限制：任意两个节点只能有一条边&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="https://lightc.top/tags/Algorithm/"/>
    
    <category term="Tree" scheme="https://lightc.top/tags/Tree/"/>
    
    <category term="Tree Traversals" scheme="https://lightc.top/tags/Tree-Traversals/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://lightc.top/2023/12/09/%E6%9C%80%E5%B0%8F%E4%BA%8C%E5%88%86%E5%A0%86/"/>
    <id>https://lightc.top/2023/12/09/%E6%9C%80%E5%B0%8F%E4%BA%8C%E5%88%86%E5%A0%86/</id>
    <published>2023-12-09T12:40:31.000Z</published>
    <updated>2023-12-17T10:36:58.643Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是最小二分堆-binary-min-heap&quot;&gt;&lt;a href=&quot;#什么是最小二分堆-binary-min-heap&quot; class=&quot;headerlink&quot; title=&quot;什么是最小二分堆 (binary min-heap)&quot;&gt;&lt;/a&gt;什么是最小二分堆 (binary min-heap)&lt;/h2&gt;&lt;p&gt;堆是一颗完整的树，而且满足最小堆性质。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小堆：每个节点都小于等于子节点。&lt;/li&gt;
&lt;li&gt;完整：仅在最底层有缺失值，且所有节点尽可能靠左。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="dataStruct" scheme="https://lightc.top/tags/dataStruct/"/>
    
    <category term="Heap" scheme="https://lightc.top/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="https://lightc.top/2023/12/09/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>https://lightc.top/2023/12/09/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2023-12-09T12:21:50.000Z</published>
    <updated>2023-12-17T10:38:48.597Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是优先队列&quot;&gt;&lt;a href=&quot;#什么是优先队列&quot; class=&quot;headerlink&quot; title=&quot;什么是优先队列&quot;&gt;&lt;/a&gt;什么是优先队列&lt;/h2&gt;&lt;p&gt;优先队列是一种用来优化处理最大值或最小值的 ADT 。使用这种结构可以给我们处理涉及最大值或最小值带来时间&amp;#x2F;空间优势。&lt;/p&gt;</summary>
    
    
    
    
    <category term="dataStruct" scheme="https://lightc.top/tags/dataStruct/"/>
    
    <category term="Priority Queue" scheme="https://lightc.top/tags/Priority-Queue/"/>
    
  </entry>
  
  <entry>
    <title>copy constructor 杂谈(一)</title>
    <link href="https://lightc.top/2023/11/30/copy-constructor-%E6%9D%82%E8%B0%88-%E4%B8%80/"/>
    <id>https://lightc.top/2023/11/30/copy-constructor-%E6%9D%82%E8%B0%88-%E4%B8%80/</id>
    <published>2023-11-30T15:45:39.000Z</published>
    <updated>2023-12-17T10:38:06.136Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;copy-constructor-的杂谈&quot;&gt;&lt;a href=&quot;#copy-constructor-的杂谈&quot; class=&quot;headerlink&quot; title=&quot;copy constructor 的杂谈&quot;&gt;&lt;/a&gt;copy constructor 的杂谈&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;copy constructor 为什么第一个参数必须为引用类型？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了减少一次内存拷贝吗？&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://lightc.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>git基础</title>
    <link href="https://lightc.top/2023/11/28/git%E5%9F%BA%E7%A1%80/"/>
    <id>https://lightc.top/2023/11/28/git%E5%9F%BA%E7%A1%80/</id>
    <published>2023-11-28T14:15:46.000Z</published>
    <updated>2023-12-17T10:37:56.900Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Git基础&quot;&gt;&lt;a href=&quot;#Git基础&quot; class=&quot;headerlink&quot; title=&quot;Git基础&quot;&gt;&lt;/a&gt;Git基础&lt;/h1&gt;&lt;h2 id=&quot;文档内容&quot;&gt;&lt;a href=&quot;#文档内容&quot; class=&quot;headerlink&quot; title=&quot;文档内容&quot;&gt;&lt;/a&gt;文档内容&lt;/h2&gt;&lt;p&gt;本文档是关于学习 MIT——The missing semester 。 大致内容为从 git 的底层数据模型开始，学习 git 的内部实现，继而理解 git 各种命令。包括：git 如何对文件&amp;#x2F;文件夹建模，历史快照（snapshots of history）是什么？&lt;/p&gt;</summary>
    
    
    
    
    <category term="git" scheme="https://lightc.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>tmux食用指南</title>
    <link href="https://lightc.top/2023/11/19/tmux%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://lightc.top/2023/11/19/tmux%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2023-11-19T13:20:30.000Z</published>
    <updated>2023-12-17T10:37:30.797Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;tmux食用指南&quot;&gt;&lt;a href=&quot;#tmux食用指南&quot; class=&quot;headerlink&quot; title=&quot;tmux食用指南&quot;&gt;&lt;/a&gt;tmux食用指南&lt;/h1&gt;&lt;h2 id=&quot;什么是tmux&quot;&gt;&lt;a href=&quot;#什么是tmux&quot; class=&quot;headerlink&quot; title=&quot;什么是tmux&quot;&gt;&lt;/a&gt;什么是tmux&lt;/h2&gt;&lt;p&gt;tmux是终端复用(teminal multiplexper)的简称。通常一个终端只能同时执行一个命令，例如，当你输入&lt;code&gt;sleep 2000&lt;/code&gt;命令后，你必须要等终端执行完这条命令，你才能执行其他的命令。这显然十分的不便。一个解决方法是同时开多个终端。Bing！tmux就是这个原理。它可以让你实现多终端，并且在这些终端里灵活切换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="tmux tool" scheme="https://lightc.top/tags/tmux-tool/"/>
    
  </entry>
  
</feed>
