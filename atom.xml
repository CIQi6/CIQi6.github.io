<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Memetor&#39;s Blog</title>
  
  
  <link href="https://lightc.top/atom.xml" rel="self"/>
  
  <link href="https://lightc.top/"/>
  <updated>2024-01-15T12:57:18.241Z</updated>
  <id>https://lightc.top/</id>
  
  <author>
    <name>Memetor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>trie</title>
    <link href="https://lightc.top/2024/01/15/trie/"/>
    <id>https://lightc.top/2024/01/15/trie/</id>
    <published>2024-01-15T11:48:22.000Z</published>
    <updated>2024-01-15T12:57:18.241Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对于搜索问题——从一堆数据中检索(retireve)我们感兴趣的数据，我们前面已经了解到了许多抽象数据结构以及其对应的具体实现。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="trie" scheme="https://lightc.top/tags/trie/"/>
    
    <category term="algorithmn" scheme="https://lightc.top/tags/algorithmn/"/>
    
  </entry>
  
  <entry>
    <title>Relflection-java</title>
    <link href="https://lightc.top/2024/01/05/Relflection-java/"/>
    <id>https://lightc.top/2024/01/05/Relflection-java/</id>
    <published>2024-01-05T05:18:51.000Z</published>
    <updated>2024-01-12T16:05:37.892Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是反射&quot;&gt;&lt;a href=&quot;#什么是反射&quot; class=&quot;headerlink&quot; title=&quot;什么是反射&quot;&gt;&lt;/a&gt;什么是反射&lt;/h2&gt;&lt;p&gt;反射就是程序在&lt;code&gt;运行时&lt;/code&gt;能够“观察”和修改自己的行为。&lt;/p&gt;
&lt;p&gt;JAVA反射机制是在运行</summary>
      
    
    
    
    
    <category term="java" scheme="https://lightc.top/tags/java/"/>
    
    <category term="Reflection" scheme="https://lightc.top/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>Shortest_Path</title>
    <link href="https://lightc.top/2023/12/31/Shortest-Path/"/>
    <id>https://lightc.top/2023/12/31/Shortest-Path/</id>
    <published>2023-12-31T05:50:30.000Z</published>
    <updated>2023-12-31T05:50:30.528Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Testing</title>
    <link href="https://lightc.top/2023/12/31/Equality_Testing/"/>
    <id>https://lightc.top/2023/12/31/Equality_Testing/</id>
    <published>2023-12-31T05:05:09.000Z</published>
    <updated>2023-12-31T05:37:36.436Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Equality-Testing&quot;&gt;&lt;a href=&quot;#Equality-Testing&quot; class=&quot;headerlink&quot; title=&quot;Equality Testing&quot;&gt;&lt;/a&gt;Equality Testing&lt;/h2&gt;&lt;p&gt;java 规定 equals 方法应该要满足以下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自反性：对于非 NULL 引用 x， &lt;code&gt;x.equals(x)&lt;/code&gt;应该返回 true&lt;/li&gt;
&lt;li&gt;对称性：对于任何 x 和 y，&lt;code&gt;x.eqauls(y)&lt;/code&gt; 和 &lt;code&gt;y.equals(x)&lt;/code&gt; 返回的结果应该相同&lt;/li&gt;
&lt;li&gt;传递性：对于任何 x 、y 和 z，&lt;code&gt;x.equals(y)&lt;/code&gt; 、&lt;code&gt;y.equals(z)&lt;/code&gt; 则 &lt;code&gt;x.equals(z)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一致性：只要 x 和 y 不变，则无论调用多少次，什么时候调用 x.equals(y) ，返回的值应该不变&lt;/li&gt;
&lt;li&gt;对于 x.equals(null) 应该返回 false&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://lightc.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>PIMPL</title>
    <link href="https://lightc.top/2023/12/19/PIMPL/"/>
    <id>https://lightc.top/2023/12/19/PIMPL/</id>
    <published>2023-12-19T09:00:08.000Z</published>
    <updated>2023-12-30T13:00:17.283Z</updated>
    
    
    <summary type="html">&lt;p&gt;Pimpl (Pointer to implementation) 是一种减少代码依赖和编译时间的 cpp 代码技巧。&lt;/p&gt;
&lt;p&gt;Pimpl 的思想是将可见类的实现放在一个单独的实现类中，在可见类中使用一个私有指针来访问实现类。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://lightc.top/tags/cpp/"/>
    
    <category term="cppIdioms" scheme="https://lightc.top/tags/cppIdioms/"/>
    
  </entry>
  
  <entry>
    <title>graph</title>
    <link href="https://lightc.top/2023/12/17/graph/"/>
    <id>https://lightc.top/2023/12/17/graph/</id>
    <published>2023-12-17T07:11:17.000Z</published>
    <updated>2023-12-17T08:19:28.855Z</updated>
    
    
    
    
    
    <category term="Algorithm" scheme="https://lightc.top/tags/Algorithm/"/>
    
    <category term="Graph" scheme="https://lightc.top/tags/Graph/"/>
    
    <category term="Graph Traversals" scheme="https://lightc.top/tags/Graph-Traversals/"/>
    
  </entry>
  
  <entry>
    <title>tree</title>
    <link href="https://lightc.top/2023/12/17/tree/"/>
    <id>https://lightc.top/2023/12/17/tree/</id>
    <published>2023-12-17T07:11:11.000Z</published>
    <updated>2023-12-17T10:37:21.012Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是树？&quot;&gt;&lt;a href=&quot;#什么是树？&quot; class=&quot;headerlink&quot; title=&quot;什么是树？&quot;&gt;&lt;/a&gt;什么是树？&lt;/h2&gt;&lt;p&gt;树的组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一组节点 (nodes)&lt;/li&gt;
&lt;li&gt;一组连接着节点的边 (edges)&lt;ul&gt;
&lt;li&gt;限制：任意两个节点只能有一条边&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Algorithm" scheme="https://lightc.top/tags/Algorithm/"/>
    
    <category term="Tree" scheme="https://lightc.top/tags/Tree/"/>
    
    <category term="Tree Traversals" scheme="https://lightc.top/tags/Tree-Traversals/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://lightc.top/2023/12/09/%E6%9C%80%E5%B0%8F%E4%BA%8C%E5%88%86%E5%A0%86/"/>
    <id>https://lightc.top/2023/12/09/%E6%9C%80%E5%B0%8F%E4%BA%8C%E5%88%86%E5%A0%86/</id>
    <published>2023-12-09T12:40:31.000Z</published>
    <updated>2023-12-17T10:36:58.643Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是最小二分堆-binary-min-heap&quot;&gt;&lt;a href=&quot;#什么是最小二分堆-binary-min-heap&quot; class=&quot;headerlink&quot; title=&quot;什么是最小二分堆 (binary min-heap)&quot;&gt;&lt;/a&gt;什么是最小二分堆 (binary min-heap)&lt;/h2&gt;&lt;p&gt;堆是一颗完整的树，而且满足最小堆性质。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小堆：每个节点都小于等于子节点。&lt;/li&gt;
&lt;li&gt;完整：仅在最底层有缺失值，且所有节点尽可能靠左。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="dataStruct" scheme="https://lightc.top/tags/dataStruct/"/>
    
    <category term="Heap" scheme="https://lightc.top/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="https://lightc.top/2023/12/09/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>https://lightc.top/2023/12/09/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2023-12-09T12:21:50.000Z</published>
    <updated>2023-12-17T10:38:48.597Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是优先队列&quot;&gt;&lt;a href=&quot;#什么是优先队列&quot; class=&quot;headerlink&quot; title=&quot;什么是优先队列&quot;&gt;&lt;/a&gt;什么是优先队列&lt;/h2&gt;&lt;p&gt;优先队列是一种用来优化处理最大值或最小值的 ADT 。使用这种结构可以给我们处理涉及最大值或最小值带来时间&amp;#x2F;空间优势。&lt;/p&gt;</summary>
    
    
    
    
    <category term="dataStruct" scheme="https://lightc.top/tags/dataStruct/"/>
    
    <category term="Priority Queue" scheme="https://lightc.top/tags/Priority-Queue/"/>
    
  </entry>
  
  <entry>
    <title>copy constructor 杂谈(一)</title>
    <link href="https://lightc.top/2023/11/30/copy-constructor-%E6%9D%82%E8%B0%88-%E4%B8%80/"/>
    <id>https://lightc.top/2023/11/30/copy-constructor-%E6%9D%82%E8%B0%88-%E4%B8%80/</id>
    <published>2023-11-30T15:45:39.000Z</published>
    <updated>2023-12-17T10:38:06.136Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;copy-constructor-的杂谈&quot;&gt;&lt;a href=&quot;#copy-constructor-的杂谈&quot; class=&quot;headerlink&quot; title=&quot;copy constructor 的杂谈&quot;&gt;&lt;/a&gt;copy constructor 的杂谈&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;copy constructor 为什么第一个参数必须为引用类型？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了减少一次内存拷贝吗？&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://lightc.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>git基础</title>
    <link href="https://lightc.top/2023/11/28/git%E5%9F%BA%E7%A1%80/"/>
    <id>https://lightc.top/2023/11/28/git%E5%9F%BA%E7%A1%80/</id>
    <published>2023-11-28T14:15:46.000Z</published>
    <updated>2023-12-17T10:37:56.900Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Git基础&quot;&gt;&lt;a href=&quot;#Git基础&quot; class=&quot;headerlink&quot; title=&quot;Git基础&quot;&gt;&lt;/a&gt;Git基础&lt;/h1&gt;&lt;h2 id=&quot;文档内容&quot;&gt;&lt;a href=&quot;#文档内容&quot; class=&quot;headerlink&quot; title=&quot;文档内容&quot;&gt;&lt;/a&gt;文档内容&lt;/h2&gt;&lt;p&gt;本文档是关于学习 MIT——The missing semester 。 大致内容为从 git 的底层数据模型开始，学习 git 的内部实现，继而理解 git 各种命令。包括：git 如何对文件&amp;#x2F;文件夹建模，历史快照（snapshots of history）是什么？&lt;/p&gt;</summary>
    
    
    
    
    <category term="git" scheme="https://lightc.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>tmux食用指南</title>
    <link href="https://lightc.top/2023/11/19/tmux%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://lightc.top/2023/11/19/tmux%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2023-11-19T13:20:30.000Z</published>
    <updated>2023-12-17T10:37:30.797Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;tmux食用指南&quot;&gt;&lt;a href=&quot;#tmux食用指南&quot; class=&quot;headerlink&quot; title=&quot;tmux食用指南&quot;&gt;&lt;/a&gt;tmux食用指南&lt;/h1&gt;&lt;h2 id=&quot;什么是tmux&quot;&gt;&lt;a href=&quot;#什么是tmux&quot; class=&quot;headerlink&quot; title=&quot;什么是tmux&quot;&gt;&lt;/a&gt;什么是tmux&lt;/h2&gt;&lt;p&gt;tmux是终端复用(teminal multiplexper)的简称。通常一个终端只能同时执行一个命令，例如，当你输入&lt;code&gt;sleep 2000&lt;/code&gt;命令后，你必须要等终端执行完这条命令，你才能执行其他的命令。这显然十分的不便。一个解决方法是同时开多个终端。Bing！tmux就是这个原理。它可以让你实现多终端，并且在这些终端里灵活切换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="tmux tool" scheme="https://lightc.top/tags/tmux-tool/"/>
    
  </entry>
  
</feed>
